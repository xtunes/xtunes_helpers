<% if is_using_unicorn %>
    upstream <%= application %>_app_server {
        server unix:<%= unicorn_socket %> fail_timeout=0;
    }
    <% end %>
    # <%= application %> Server
    server {
        listen <%= application_port %>;
        <% if is_using_passenger %>
        rails_env <%= rails_env %>;
        passenger_enabled on;
        passenger_ruby <%= passenger_ruby %>;
        <% end %>
        client_max_body_size 500M;
        client_body_buffer_size 2048k;
        server_name <%= server_name %>;

        # ~2 seconds is often enough for most folks to parse HTML/CSS and
        # retrieve needed images/icons/frames, connections are cheap in
        # nginx so increasing this is generally safe...
        keepalive_timeout 5;

        # path for static files
        root <%= deploy_to %>/current/public;
        <% if has_global_access_log %>
        access_log <%= global_access_log%>;
        <% end %>
        # access_log <%= deploy_to %>/shared/log/nginx.access.log main;
        # error_log  <%= deploy_to %>/shared/log/nginx.error.log info;

        # this rewrites all the requests to the maintenance.html
        # page if it exists in the doc root. This is for capistrano's
        # disable web task
        if (-f $document_root/system/maintenance.html) {
          rewrite  ^(.*)$  /system/maintenance.html last;
          break;
        }

        location / {
          <% if is_using_passenger %>
          rails_env <%= rails_env %>;
          passenger_enabled on;
          passenger_set_cgi_param HTTP_X_ACCEL_MAPPING /=/sec/;
          passenger_pass_header X-Accel-Redirect;
          <% end %>

          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
          proxy_set_header Host $http_host;

          # If the file exists as a static file serve it directly without
          # running all the other rewite tests on it
          if (-f $request_filename) {
            break;
          }

          # check for index.html for directory index
          # if its there on the filesystem then rewite
          # the url to add /index.html to the end of it
          # and then break to send it to the next config rules.
          if (-f $request_filename/index.html) {
            rewrite (.*) $1/index.html break;
          }

          # this is the meat of the rails page caching config
          # it adds .html to the end of the url and then checks
          # the filesystem for that file. If it exists, then we
          # rewite the url to have explicit .html on the end
          # and then send it on its way to the next config rule.
          # if there is no file on the fs then it sets all the
          # necessary headers and proxies to our upstream mongrels
          if (-f $request_filename.html) {
            rewrite (.*) $1.html break;
          }

          <% if is_using_unicorn %>
          if (!-f $request_filename) {
            proxy_pass http://<%= application %>_app_server;
            break;
          }
          <% end %>
        }
        <% if is_using_passenger %>
        location /sec/ {
          alias /;
          internal;
        }
        <% end %>

        location ~ ^/assets/ {
          add_header Cache-Control public;
          expires max;
          add_header ETag "";
          gzip_static on; # to serve pre-gzipped version
          expires max;
          break;
        }

        # Rails error pages
        error_page 500 502 503 504 /500.html;
        location = /500.html {
          root <%= deploy_to %>/current/public;
        }
    }

    <% if application_uses_ssl %>

    <% if is_using_unicorn %>
    upstream <%= application %>_app_ssl {
      server unix:<%= unicorn_socket %> fail_timeout=0;
    }
    <% end %>

    # This server is setup for ssl. Uncomment if
    # you are using ssl as well as port 80.
    server {
      listen <%= application_port_ssl%>;
      server_name <%= application %>;
      <% if is_using_passenger %>
      rails_env <%= rails_env %>;
      passenger_enabled on;
      <% end %>
      ssl                     on;
      ssl_certificate         /etc/ssl/certs/server.crt;
      ssl_certificate_key     /etc/ssl/private/server.key;
      ssl_session_timeout     5m;
      client_max_body_size    50M;

      root <%= deploy_to %>/current/public;
      access_log <%= deploy_to %>/current/log/nginx.access.log main;
      error_log  <%= deploy_to %>/current/log/nginx.error.log info;

      # this rewrites all the requests to the maintenance.html
      # page if it exists in the doc root. This is for capistrano's
      # disable web task
      if (-f $document_root/system/maintenance.html) {
        rewrite  ^(.*)$  /system/maintenance.html last;
        break;
      }

      location / {
        <% if is_using_passenger %>
        rails_env <%= rails_env %>;
        passenger_enabled on;
        <% end %>

        # needed to forward user's IP address to rails
        proxy_set_header  X-Real-IP  $remote_addr;

        # needed for HTTPS
        proxy_set_header X_FORWARDED_PROTO https;

        proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header Host $http_host;
        proxy_redirect off;
        proxy_max_temp_file_size 0;


        # If the file exists as a static file serve it directly without
        # running all the other rewite tests on it
        if (-f $request_filename) {
          break;
        }

        # check for index.html for directory index
        # if its there on the filesystem then rewite
        # the url to add /index.html to the end of it
        # and then break to send it to the next config rules.
        if (-f $request_filename/index.html) {
          rewrite (.*) $1/index.html break;
        }

        # this is the meat of the rails page caching config
        # it adds .html to the end of the url and then checks
        # the filesystem for that file. If it exists, then we
        # rewite the url to have explicit .html on the end
        # and then send it on its way to the next config rule.
        # if there is no file on the fs then it sets all the
        # necessary headers and proxies to our upstream mongrels
        if (-f $request_filename.html) {
          rewrite (.*) $1.html break;
        }

        <% if is_using_unicorn %>
        if (!-f $request_filename) {
          proxy_pass http://<%= application %>_app_ssl;
          break;
        }
        <% end %>
      }

      error_page   500 502 503 504  /500.html;
      location = /500.html {
        root   <%= deploy_to %>/current/public;
      }
    }
    <% end %>
